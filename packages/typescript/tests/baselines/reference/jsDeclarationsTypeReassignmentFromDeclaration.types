=== /some-mod.d.ts ===
interface Item {
    x: string;
>x : string
}
declare const items: Item[];
>items : Item[]

export = items;
>items : Item[]

=== tests/cases/conformance/jsdoc/declarations/index.js ===
/** @type {typeof import("/some-mod")} */
const items = [];
>items : Item[]
>[] : undefined[]

module.exports = items;
>module.exports = items : { [n: number]: Item; length: number; toString(): string; toLocaleString(): string; pop(): Item; push(...items: Item[]): number; concat(...items: ConcatArray<Item>[]): Item[]; concat(...items: (Item | ConcatArray<Item>)[]): Item[]; join(separator?: string): string; reverse(): Item[]; shift(): Item; slice(start?: number, end?: number): Item[]; sort(compareFn?: (a: Item, b: Item) => number): Item[]; splice(start: number, deleteCount?: number): Item[]; splice(start: number, deleteCount: number, ...items: Item[]): Item[]; unshift(...items: Item[]): number; indexOf(searchElement: Item, fromIndex?: number): number; lastIndexOf(searchElement: Item, fromIndex?: number): number; every<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): this is S[]; every(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; some(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; forEach(callbackfn: (value: Item, index: number, array: Item[]) => void, thisArg?: any): void; map<U>(callbackfn: (value: Item, index: number, array: Item[]) => U, thisArg?: any): U[]; filter<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): S[]; filter(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): Item[]; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduce<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduceRight<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; find<S extends Item>(predicate: (this: void, value: Item, index: number, obj: Item[]) => value is S, thisArg?: any): S; find(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): Item; findIndex(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): number; fill(value: Item, start?: number, end?: number): Item[]; copyWithin(target: number, start: number, end?: number): Item[]; entries(): IterableIterator<[number, Item]>; keys(): IterableIterator<number>; values(): IterableIterator<Item>; [Symbol.iterator](): IterableIterator<Item>; [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; }; }
>module.exports : { [n: number]: Item; length: number; toString(): string; toLocaleString(): string; pop(): Item; push(...items: Item[]): number; concat(...items: ConcatArray<Item>[]): Item[]; concat(...items: (Item | ConcatArray<Item>)[]): Item[]; join(separator?: string): string; reverse(): Item[]; shift(): Item; slice(start?: number, end?: number): Item[]; sort(compareFn?: (a: Item, b: Item) => number): Item[]; splice(start: number, deleteCount?: number): Item[]; splice(start: number, deleteCount: number, ...items: Item[]): Item[]; unshift(...items: Item[]): number; indexOf(searchElement: Item, fromIndex?: number): number; lastIndexOf(searchElement: Item, fromIndex?: number): number; every<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): this is S[]; every(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; some(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; forEach(callbackfn: (value: Item, index: number, array: Item[]) => void, thisArg?: any): void; map<U>(callbackfn: (value: Item, index: number, array: Item[]) => U, thisArg?: any): U[]; filter<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): S[]; filter(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): Item[]; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduce<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduceRight<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; find<S extends Item>(predicate: (this: void, value: Item, index: number, obj: Item[]) => value is S, thisArg?: any): S; find(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): Item; findIndex(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): number; fill(value: Item, start?: number, end?: number): Item[]; copyWithin(target: number, start: number, end?: number): Item[]; entries(): IterableIterator<[number, Item]>; keys(): IterableIterator<number>; values(): IterableIterator<Item>; [Symbol.iterator](): IterableIterator<Item>; [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; }; }
>module : { exports: { [n: number]: Item; length: number; toString(): string; toLocaleString(): string; pop(): Item; push(...items: Item[]): number; concat(...items: ConcatArray<Item>[]): Item[]; concat(...items: (Item | ConcatArray<Item>)[]): Item[]; join(separator?: string): string; reverse(): Item[]; shift(): Item; slice(start?: number, end?: number): Item[]; sort(compareFn?: (a: Item, b: Item) => number): Item[]; splice(start: number, deleteCount?: number): Item[]; splice(start: number, deleteCount: number, ...items: Item[]): Item[]; unshift(...items: Item[]): number; indexOf(searchElement: Item, fromIndex?: number): number; lastIndexOf(searchElement: Item, fromIndex?: number): number; every<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): this is S[]; every(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; some(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; forEach(callbackfn: (value: Item, index: number, array: Item[]) => void, thisArg?: any): void; map<U>(callbackfn: (value: Item, index: number, array: Item[]) => U, thisArg?: any): U[]; filter<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): S[]; filter(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): Item[]; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduce<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduceRight<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; find<S extends Item>(predicate: (this: void, value: Item, index: number, obj: Item[]) => value is S, thisArg?: any): S; find(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): Item; findIndex(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): number; fill(value: Item, start?: number, end?: number): Item[]; copyWithin(target: number, start: number, end?: number): Item[]; entries(): IterableIterator<[number, Item]>; keys(): IterableIterator<number>; values(): IterableIterator<Item>; [Symbol.iterator](): IterableIterator<Item>; [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; }; }; }
>exports : { [n: number]: Item; length: number; toString(): string; toLocaleString(): string; pop(): Item; push(...items: Item[]): number; concat(...items: ConcatArray<Item>[]): Item[]; concat(...items: (Item | ConcatArray<Item>)[]): Item[]; join(separator?: string): string; reverse(): Item[]; shift(): Item; slice(start?: number, end?: number): Item[]; sort(compareFn?: (a: Item, b: Item) => number): Item[]; splice(start: number, deleteCount?: number): Item[]; splice(start: number, deleteCount: number, ...items: Item[]): Item[]; unshift(...items: Item[]): number; indexOf(searchElement: Item, fromIndex?: number): number; lastIndexOf(searchElement: Item, fromIndex?: number): number; every<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): this is S[]; every(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; some(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): boolean; forEach(callbackfn: (value: Item, index: number, array: Item[]) => void, thisArg?: any): void; map<U>(callbackfn: (value: Item, index: number, array: Item[]) => U, thisArg?: any): U[]; filter<S extends Item>(predicate: (value: Item, index: number, array: Item[]) => value is S, thisArg?: any): S[]; filter(predicate: (value: Item, index: number, array: Item[]) => unknown, thisArg?: any): Item[]; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduce(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduce<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item): Item; reduceRight(callbackfn: (previousValue: Item, currentValue: Item, currentIndex: number, array: Item[]) => Item, initialValue: Item): Item; reduceRight<U>(callbackfn: (previousValue: U, currentValue: Item, currentIndex: number, array: Item[]) => U, initialValue: U): U; find<S extends Item>(predicate: (this: void, value: Item, index: number, obj: Item[]) => value is S, thisArg?: any): S; find(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): Item; findIndex(predicate: (value: Item, index: number, obj: Item[]) => unknown, thisArg?: any): number; fill(value: Item, start?: number, end?: number): Item[]; copyWithin(target: number, start: number, end?: number): Item[]; entries(): IterableIterator<[number, Item]>; keys(): IterableIterator<number>; values(): IterableIterator<Item>; [Symbol.iterator](): IterableIterator<Item>; [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; }; }
>items : Item[]

